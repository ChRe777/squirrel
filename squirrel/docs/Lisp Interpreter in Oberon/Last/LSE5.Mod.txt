MODULE LSE;

	IMPORT
		LSG, LSO, LSP;
		
	TYPE
		cell = LSG.cell;
		atomCell = LSG.atomCell;
		consCell = LSG.consCell;
		identifier*  = LSG.identifier;
		
	VAR
		QUOTE*, ATOM*, EQ*, CAR*, CDR*, CONS*, COND*, 
		TAGGED*, TYPE0*, TAG*, REP*,
		SYM*,
		LABEL*, LAMBDA*, T*, EMPTY*: cell;
		ENV*: cell;
	
	PROCEDURE error  (errno: INTEGER);
	BEGIN
		(* TODO *)
	END error;			
						
	(* BEGIN  7 primitive operators *)
													
	PROCEDURE quote(x: cell): cell;
	BEGIN RETURN cadr(x);
	END quote;
		
	PROCEDURE atom(x: cell): cell;
	BEGIN
		IF x IS atomCell THEN RETURN T;
		ELSE RETURN EMPTY END;
	END atom;
	
	PROCEDURE eq(x: cell; y: cell): cell; 
	BEGIN
		IF (x = EMPTY)  &  (y = EMPTY) THEN RETURN T;
		ELSIF (x IS atomCell) & (y IS atomCell) THEN
				IF x(atomCell).name = y(atomCell).name THEN RETURN T END;
		END;
		RETURN EMPTY;	
	END eq;

	PROCEDURE car(x: cell): cell;
	BEGIN
		IF x IS consCell THEN
			IF x = EMPTY THEN RETURN EMPTY;
			ELSE RETURN LSG.car(x) END;
		ELSE
			error(1); (* TODO - error: can not take car of foo *)
		END;
	END car;
	
	PROCEDURE cdr(e: cell): cell;
	BEGIN
		IF e IS consCell THEN
			IF e = EMPTY THEN RETURN EMPTY;
			ELSE RETURN LSG.cdr(e) END;
		ELSE
			error(1); (* TODO - error: can not take cdr of foo *)
		END;
	END cdr;
	
	PROCEDURE cons(x:cell; y:cell): cell; (* TODO: dotted pair (cons 'a 'b) -> (a . b) *)
	BEGIN
		IF y IS consCell THEN
			RETURN LSG.cons(x, y);
		ELSE
			error(1); (* TODO - error: y must be a list *)
		END;
	END cons;
	
	PROCEDURE cond(x: cell): cell;
	BEGIN
		IF x IS consCell THEN
			IF eq(caar(x), T) = T THEN RETURN cadar(x);				
			ELSE RETURN cond(cdr(x)) END;
		ELSE
			error(1); (* TODO: x must be a list of from ((p1 e1) (p2 e2) .. (pn en)) *)		
		END;
	END cond;
	
	(* END 7 primitive operator *)
	
	(* NEW 2-3 primitive operator *)
	
	
		PROCEDURE isTagged(e: cell): BOOLEAN;
			VAR x: cell;
		BEGIN
		
			(* ('TAGGED #TYPE #REP) 
				((QUOTE TAGGED) #TYPE #REP)
			*)
		
			IF  (e IS consCell) THEN
				x := car(e);
				IF (x IS consCell) & (eq(caar(e), QUOTE) = T) &  (eq(cadar(e), TAGGED) = T) THEN
					RETURN TRUE;
				ELSE
					RETURN FALSE;
				END;
			ELSE 
				RETURN FALSE;
			END;
		END isTagged;
	
	PROCEDURE tag*(type: cell; rep: cell): cell;
		VAR tc, t: cell;
	BEGIN
		(* ('tag TYPE REP) *)
		tc := cons(A("QUOTE"), cons(A("TAGGED"), EMPTY));
		t := cons(tc, cons(type, cons(rep, EMPTY)));	
		RETURN t;
	END tag;

	PROCEDURE type*(e: cell): cell;
	BEGIN
		IF e IS consCell THEN 
			RETURN A("CONS");
		ELSE 
			RETURN A("SYM");
		END;
	END type;

	PROCEDURE type0*(e: cell): cell;
			
		PROCEDURE tagType(e: cell): cell;
		BEGIN
			RETURN cadr(e);
		END tagType;
		
	BEGIN (* type *)
		IF isTagged(e) THEN
			RETURN tagType(e);
		ELSE
			RETURN type(e);			
		END;
	END type0;
	
	PROCEDURE rep*(e: cell): cell;
	BEGIN
		(* ((QUOTE TAGGED) #TYPE #REP) *)
		IF isTagged(e) THEN
			RETURN caddr(e);
		ELSE
			RETURN cadr(e);
		END;
	END rep;
	
	(* BEGIN 2-3 primitive operator *)

	(* TODO below should be implemented in LISP itself *)
	
	PROCEDURE pair(x: cell; y: cell): cell;
	BEGIN
		IF  (x = EMPTY) & (y = EMPTY) THEN RETURN EMPTY;
		ELSE
			IF (x IS consCell) & (y IS consCell) THEN
				RETURN cons(list(car(x),car(y)), pair(cdr(x), cdr(y)));
			END;
		END; 
	END pair;
	
	PROCEDURE null(x: cell): cell;
	BEGIN
		IF (x IS consCell) THEN
			IF x = EMPTY THEN RETURN T; END;
		END;
		RETURN EMPTY;
	END null;
		
	PROCEDURE not(x: cell): cell;
	BEGIN
		IF eq(x, T) = T THEN RETURN EMPTY;
		ELSE RETURN T END;
	END not;
	
	PROCEDURE and(x:cell; y: cell): cell;
	BEGIN
		IF eq(x,T) = T THEN
			IF eq(y,T) = T THEN RETURN T;
			ELSE RETURN EMPTY END;
		ELSE
			RETURN EMPTY;
		END;
	END and;
	
	PROCEDURE append(x: cell; y: cell): cell;
	BEGIN
		IF x = EMPTY THEN RETURN y;
		ELSE
			RETURN cons(car(x), append(cdr(x), y));
		END;
	END append;
	
	PROCEDURE list(x: cell; y: cell): cell;
	BEGIN
		RETURN cons(x, cons(y, EMPTY));
	END list;
					
	PROCEDURE assoc(x: cell; y: cell): cell;
	BEGIN
		IF y = EMPTY THEN RETURN EMPTY;
		ELSE
			IF eq(caar(y), x) = T THEN RETURN cadar(y);
			ELSE RETURN assoc(x, cdr(y)); END;
		END;
	END assoc;
		
	PROCEDURE caar(e: cell): cell; BEGIN RETURN car(car(e)) END caar;
	PROCEDURE cadr(e: cell): cell; BEGIN RETURN car(cdr(e)) END cadr;
	PROCEDURE cadar(e: cell): cell; BEGIN RETURN car(cdr(car(e))) END cadar;
	PROCEDURE caddr(e: cell): cell; BEGIN RETURN car(cdr(cdr(e))) END caddr;
	PROCEDURE caddar(e: cell): cell; BEGIN RETURN car(cdr(cdr(car(e)))) END caddar;
			
	PROCEDURE eval*(e: cell; a: cell): cell;
		VAR c: cell;
	BEGIN
		IF e IS atomCell THEN RETURN assoc(e, a) END; 
		c := car(e);
		IF c IS atomCell THEN
			IF eq(car(e), QUOTE) = T THEN RETURN quote(e);
			ELSIF eq(car(e), ATOM) = T THEN RETURN atom(eval(cadr(e), a));
			ELSIF eq(car(e), EQ) = T THEN RETURN eq(eval(cadr(e), a), eval(caddr(e), a));
			ELSIF eq(car(e), CAR) = T THEN RETURN car(eval(cadr(e), a));
			ELSIF eq(car(e), CDR) = T THEN RETURN cdr(eval(cadr(e), a));
			ELSIF eq(car(e), CONS) = T THEN RETURN cons(eval(cadr(e), a), eval(caddr(e), a));
			ELSIF eq(car(e), COND) = T THEN RETURN evcon(cdr(e), a);
			ELSIF eq(car(e), TAG) = T THEN RETURN tag(eval(cadr(e), a), eval(caddr(e), a));
			ELSIF eq(car(e), TYPE0) = T THEN RETURN type0(eval(cadr(e), a));
			ELSIF eq(car(e), REP) = T THEN RETURN rep(eval(cadr(e), a));
			ELSE RETURN eval(cons(assoc(car(e), a), cdr(e)), a); END;
		END;
		IF eq(caar(e), LABEL) = T THEN 
				RETURN eval( 
					cons(caddar(e), cdr(e)),
					cons(list(cadar(e), car(e)), a)
				);
		END;
		IF eq(caar(e), LAMBDA) = T THEN  
			RETURN eval(
					caddar(e),
					append(pair(cadar(e), evlis(cdr(e), a)), a)
				);
		END;
	END eval;
		
	PROCEDURE evcon(c: cell; a: cell): cell;
	BEGIN	
		IF eq(eval(caar(c), a), T) = T THEN RETURN eval(cadar(c), a);
		ELSE RETURN evcon(cdr(c), a) END;
	END evcon;
	
	PROCEDURE evlis(m: cell; a: cell): cell;
	BEGIN
		 IF m = EMPTY THEN RETURN EMPTY;
		 ELSE
		 	 RETURN cons(eval(car(m), a), evlis(cdr(m), a))
		 END;
	END evlis;
		
	PROCEDURE A(name: identifier): cell;
	BEGIN RETURN LSG.atom(name); 
	END A;
		
BEGIN

	QUOTE := A("QUOTE"); 
	ATOM := A("ATOM");
	EQ := A("EQ"); 
	CAR := A("CAR");
	CDR := A("CDR"); 
	CONS := A("CONS");
	COND := A("COND"); 
	
	TAGGED := A("TAGGED");
	SYM := A("SYM");
	TYPE0 := A("TYPE");
	TAG := A("TAG");
	REP := A("REP");
	
	LABEL := A("LABEL");
	LAMBDA := A("LAMBDA"); 
	T := A("T"); (*TRUE*)
	
	EMPTY := LSG.EMPTY; (*EMPTY LIST, FALSE*)
	ENV := LSG.cons(NIL,NIL); (*ENVIROMENT*)	
	
END LSE.

(*
	
	http://paulgraham.com/rootsoflisp.html

	; The Lisp defined in McCarthy's 1960 paper, translated into CL.
	; Assumes only quote, atom, eq, cons, car, cdr, cond.
	; Bug reports to lispcode@paulgraham.com.

	(defun null. (x)
	  (eq x '()))

	(defun and. (x y)
	  (cond (x (cond (y 't) ('t '())))
			('t '())))

	(defun not. (x)
	  (cond (x '())
			('t 't)))

	(defun append. (x y)
	  (cond ((null. x) y)
			('t (cons (car x) (append. (cdr x) y)))))

	(defun list. (x y)
	  (cons x (cons y '())))

	(defun pair. (x y)
	  (cond ((and. (null. x) (null. y)) '())
			((and. (not. (atom x)) (not. (atom y)))
			 (cons (list. (car x) (car y))
				   (pair. (cdr x) (cdr y))))))

	(defun assoc. (x y)
	  (cond ((eq (caar y) x) (cadar y))
			('t (assoc. x (cdr y)))))

	(defun eval. (e a)
	  (cond
	  
		((atom e) (assoc. e a))
		
		((atom (car e))
		 (cond
		   ((eq (car e) 'quote) (cadr e))
		   ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
		   ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
										(eval. (caddr e) a)))
		   ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
		   ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
		   ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
										(eval. (caddr e) a)))
		   ((eq (car e) 'cond)  (evcon. (cdr e) a))
		   ('t (eval. (cons (assoc. (car e) a)
							(cdr e))
					  a))))
					  
		((eq (caar e) 'label)
		 (eval. (cons (caddar e) (cdr e))
				(cons (list. (cadar e) (car e)) a)))
				
		((eq (caar e) 'lambda)
		 (eval. (caddar e)
				(append. (pair. (cadar e) (evlis. (cdr e) a))
						 a)))))

	(defun evcon. (c a)
	  (cond ((eval. (caar c) a)
			 (eval. (cadar c) a))
			('t (evcon. (cdr c) a))))

	(defun evlis. (m a)
	  (cond ((null. m) '())
			('t (cons (eval.  (car m) a)
					  (evlis. (cdr m) a)))))
					  
*)


   
   