MODULE LSG;	IMPORT		LSS;	CONST		CONS* = 1;		ATOM* = 2;		NUM* = 3;		INT* = 4;	  	VAR		EMPTY* : cell;				TYPE		identifier*  = LSS.identifier; (*ARRAY IdLen OF CHAR; *)		cellType* = INTEGER;		cellDesc* = RECORD			type*: cellType;		END;		cell* = POINTER TO cellDesc;		atomCellDesc* = RECORD (cellDesc)			name*: identifier;		END;		atomCell* = POINTER TO atomCellDesc;						consCellDesc* = RECORD (cellDesc)			car*: cell;			cdr*: cell;		END;		consCell* = POINTER TO consCellDesc;	PROCEDURE atom*(name: identifier): cell;		VAR ac: atomCell;	BEGIN		NEW(ac); ac.type := ATOM; ac.name := name;		RETURN ac;	END atom;		PROCEDURE cons*(car: cell; cdr: cell): cell;		VAR cc: consCell;	BEGIN		NEW(cc); cc.type := CONS; cc.car := car; cc.cdr := cdr;		RETURN cc;	END cons;		PROCEDURE quote*(c: cell): cell;	BEGIN		RETURN cons(atom("QUOTE"), cons(c, EMPTY));	END quote;		PROCEDURE add*(l, c: cell): cell;		VAR li: cell;	BEGIN 		li := l;		IF l # EMPTY THEN			WHILE l(consCell).cdr # EMPTY DO l := l(consCell).cdr END;			l(consCell).cdr := cons(c, EMPTY);		ELSE			li := cons(c, EMPTY);		END;		RETURN li;	END add;		PROCEDURE list*(): cell;	BEGIN RETURN EMPTY;	END list;		PROCEDURE cdr*(c: cell): cell;	BEGIN		IF c IS consCell THEN RETURN c(consCell).cdr END;	END cdr;		PROCEDURE car*(c: cell): cell;	BEGIN		IF c IS consCell THEN RETURN c(consCell).car END;	END car;			BEGIN	EMPTY := cons(NIL,NIL);	END LSG.      