MODULE LSS;	IMPORT		Texts, Oberon, Out;	CONST IdLen = 32;	(*			EBNF of Lisp:		----------		1 sexpr = atom | list | quoted-sexpr  (* | backquoted-sexpt | backquoted-slicing *)					1.1 atom = symbol | string | number |			1.2 list = "("{sexpr}")"			1.3 quoted-sexpr = "'" sexpr.			1.4 backquoted-sexpr = "," sexpr	*)				lparen* = 0;		symbol* = 10; string* = 11; number* = 12;  (* all atom types *)		quote* = 20; backquote* = 21;		rparen* = 100;  		other* = 255; (* EOF *)				(* ACHTUNG!! REIHENFOLGE IST WICHTIG			WHILE sym < rparen DO				symbol | string | list | number | .... then rparen )		*)			TYPE identifier* = ARRAY IdLen OF CHAR;		VAR  ch: CHAR;		sym*: INTEGER;			id*: identifier;			R: Texts.Reader; W: Texts.Writer;		(*			error: BOOLEAN; errpos: LONGINT;		*)		    	DEBUG: BOOLEAN;				PROCEDURE NextCh; 	BEGIN Texts.Read(R, ch) 	END NextCh;		PROCEDURE printSym;	BEGIN		Out.String("sym: "); Out.Int(sym,3); Out.String("  ");		CASE sym OF			symbol: Out.String("symbol: "); Out.String(id); | 			string: Out.String("string: "); Out.String(id); |			lparen: Out.String("lparen: ("); |			rparen: Out.String("rparen: )"); |			quote: Out.String("quote: '"); |			backquote: Out.String("backquote: ,"); |			other: Out.String("other");		END; Out.Ln;	END printSym;		PROCEDURE Mark*(msg: ARRAY OF CHAR); 		VAR p: LONGINT;	BEGIN		(* 		p := Texts.Pos(R) - 1;		IF p > errpos THEN			Texts.WriteString(W, "  pos  "); Texts.WriteInt(W, p, 1);			Texts.Write(W, " "); Texts.WriteString(W, msg);			Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);		END;		*)	END Mark;				PROCEDURE GetSym*;		VAR i: INTEGER;				PROCEDURE readSymbol;		BEGIN i := 0;			REPEAT id[i] := ch; INC(i); NextCh; UNTIL (CAP(ch) < "A") OR (CAP(ch) > "Z");			id[i] := 0X; (* Terminate String with 0X - e.g. Chars: A,B,C,0X = "ABC" *)		END readSymbol;				PROCEDURE readString;		BEGIN			NextCh; i := 0;			WHILE (ch # 22X) & (ch > " ") DO 			(* ch > " " all ASCII without control characters, see ASCII table *)				id[i] := ch; INC(i); NextCh;			END;			IF ch <= " " THEN Mark("No control chars allowed in string") END;			id[i] := 0X; NextCh;		END readString;			BEGIN (* GetSym *)		WHILE ~R.eot & (ch <= " ") DO NextCh; END; (* Skip blanks - all kind of control chars like \n \r SPACE TAB *)		CASE ch OF			"A".."Z","a".."z": 			        sym := symbol; readSymbol; |				27X: sym := quote; NextCh; |			22X: sym := string; readString; |					"(":  sym := lparen; NextCh; |						")":  sym := rparen; NextCh; |			ELSE sym := other; NextCh; (* eot *)		END;		IF (DEBUG) THEN printSym END;	END GetSym;		PROCEDURE Init*(T: Texts.Text; pos: LONGINT);			(*		PROCEDURE printCh;		BEGIN			Texts.Read(R,ch); Out.Char(ch); Out.String("{"); Out.Int(ORD(ch),2); Out.String(","); Out.Int(Texts.Pos(R),2); Out.String("}"); Out.Ln;		END printCh;		*)		BEGIN (* Init *)		(*error := FALSE; errpos := pos;*)		Texts.OpenReader(R, T, pos);		IF (DEBUG) THEN Out.String("LSS.Init"); Out.Ln END;		NextCh;	END Init;BEGIN	DEBUG := FALSE;END LSS.