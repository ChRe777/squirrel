MODULE LSE;	IMPORT		LSG;	(* InitEnv *)	PROCEDURE InitEnv(): cell;		VAR env: consCell;				PROCEDURE functionSymbol(name: String, fn: function): cell;			VAR fc: functionCell;		BEGIN			RETURN cons( atom(name), cons(func(fn), NIL) );		END functionSymbol;			BEGIN			tee := atom("#T");		nul := cons(NIL, NIL);				env := cons(functionSymbol("QUOTE", fnQuote), NIL);		append(env, cons(functionSymbol("ATOM", fnAtom));		append(env, cons(functionSymbol("EQ", fnEq));				append(env, cons(functionSymbol("CAR", fnCar));		append(env, cons(functionSymbol("CDR", fnCdr));		append(env, cons(functionSymbol("CONS", fnCons));		append(env, cons(functionSymbol("COND", fnCond));				append(env, cons(functionSymbol("LABEL", fnLabel));		append(env, cons(functionSymbol("LAMBDA", fnLambda));				RETURN env;			END InitEnv;		(* BUILT IN FUNCTIONS *)	(* fnQuote *)	PROCEDURE fnQuote(args: cell, env: cell): cell;	BEGIN		RETURN car(args);	END fnQuote;		(* fnAtom *)		PROCEDURE fnAtom(args: cell, env: cell): cell;		VAR firstArg: consCell;	BEGIN		firstArg := car(args);		IF isCons(firstArg) THEN 			RETURN nul;		ELSE			RETURN tee;	END fnAtom;		(* fnEq *)		PROCEDURE fnEq(args: cell, env: cell): cell;		VAR firstArg, secondArg: consCell;	BEGIN		firstArg := car(args);		secondArg := car(cdr(args));		IF cellName(firstArg) = cellName(secondArg) THEN			RETURN tee;		ELSE			RETURN nul;	END fnEq;	(* fnCar *)	PROCEDURE fnCar(args: cell, env: cell): cell;		VAR firstArg: consCell;	BEGIN		firstArg := car(args);		RETURN car(firstArg);	END fnCar;		(* fnCdr *)	PROCEDURE fnCdr(args: cell, env: cell): cell;		VAR firstArg: consCell;	BEGIN		firstArg := car(args);		RETURN cdr(firstArg);	END fnCdr;			(*	static object *fn_cons(object *args, object *env)	{		object *list = cons(car(args), NULL);		args = car(cdr(args));		// @@@		while (args != NULL && IS_CONS(args)) {			ppend(list, car(args));			args = cdr(args);		}		return list;	}	*)		(* fnCons *)	PROCEDURE fnCons(args: cell, env: cell): cell;		VAR list: consCell;	BEGIN		list := cons(car(args), NIL);		args := car(cdr(args);		WHILE (args # NIL) & isCons(args) DO			append(list, car(args));			args := cdr(args);		END;				RETURN list;	END fnCons;		(*	static object *create_parameter_pairs(object *parameters, object *arguments)	{		object *pairs;		object *pair;		object *param, *arg;		param = car(parameters);		arg   = car(arguments);		pair = cons(param, cons(arg, NULL));		pairs = cons(pair, NULL);		parameters = cdr(parameters);		arguments = cdr(arguments);		while (parameters != NULL && IS_CONS(parameters)) {			param = car(parameters);			arg   = car(arguments);			pair = cons(param, cons(arg, NULL));			append(pairs, pair);			parameters = cdr(parameters);			arguments  = cdr(arguments);		}		return pairs;	}	*)	(* createParameterPairs *)	PROCEDURE createParameterPairs(parameters: cell, arguments: cell): cell;		VAR pairs: cell; pair: cell; param, arg: cell;	BEGIN			param := car(parameters);		arg := car(arguments);		pair := cons(param, cons(arg, NIL);				pairs := cons(pair, NIL);				parameters := cdr(parameters);		arguments := cdr(arguments);				WHILE (parameters # NIL) & (isCons(paramters)) DO			param := car(parameters);			arg := car(arguments);			pair := cons(param, cons(arg, NIL);						append(pairs, pair); (* could be slow ?? *)						parameters := cdr(parameters);			arguments := cdr(arguments);		END;			END createParameterPairs;		(*	static object *replace_atom(object *sexp, object *parameter_pairs)	{		if (IS_CONS(sexp)) {			object *list;			list = cons(replace_atom(car(sexp), parameter_pairs), NULL);			sexp = cdr(sexp);			while (sexp != NULL && IS_CONS(sexp)) {				append(list, replace_atom(car(sexp), parameter_pairs));				sexp = cdr(sexp);			}			return list;		} else {			object *tmp = parameter_pairs;			while (tmp != NULL && IS_CONS(tmp)) {				object *pair = car(tmp);				object *parameter = car(pair);				object *argument = car(cdr(pair));				if (strcmp(object_name(parameter), object_name(sexp)) == 0)					return argument;				tmp = cdr(tmp);			}			return sexp;		}	}	*)	(* replaceAtom *)	PROCEDURE replaceAtom(sexp: cell; parameterPairs: cell): cell;		VAR list: cell;	BEGIN		IF isCons(sexp) THEN			list := cons(replaceAtom(car(sexp), parameterPairs), NIL);			sexpr := cdr(sexp);			WHILE (sexp # NIL) & (isCons(sexop)) DO				append(list, replaceAtom(car(sexp), parameter_pairs));				sexp := cdr(sexp);			END;			RETURN list;		ELSE			tmp := parameterPairs;						WHILE (tmp # NIL) & (isCons(tmp)) DO				pair := car(tmp);				parameter = car(pair);				argument = car(cdr(pair));								IF objectName(parameter) = objectName(sexp) THEN					RETURN argument;				END;								tmp := cdr(tmp);			END;						RETURN sexp;		END;			END replaceAtom;		(*	object *fn_lambda(object *args, object *env)	{		lambda_object *lambda;		object *arguments, *sexp;		object *parameter_pairs;		lambda    = (lambda_object* )car(args);		arguments = cdr(args);		parameter_pairs = create_parameter_pairs(lambda->args, arguments);		sexp = replace_atom(lambda->sexp, parameter_pairs);		return eval(sexp, env);	}	*)		(* fnLambda *)	PROCEDURE fnLambda(args: cell, env: cell): cell;		VAR lambda: lambdaCell; arguments, sexp, parameterPairs: cell;	BEGIN		lambda := car(args)(lambdaCell);		arguments := cdr(args);		parameterPairs := createParameterPairs(lambda.args, arguments);		sexp := replaceAtom(lambda.sexp, parameterPairs);				RETURN eval(sexp, env);	END fnLambda;	(*		static object *fn_label(object *args, object *env)	{		object *first_arg = car(args);		object *symbol = atom(object_name(first_arg));		object *value  = car(cdr(args));		append(env, cons(symbol, cons(value, NULL)));		return tee;	}	*)	(* fn Label *)	PROCEDURE fnLabel(args: cell, env: cell): cell;		VAR firstArg, symbol, value: cell;	BEGIN				firstArg := car(args);		symbol := atom(objectName(firstArg));		value := car(cdr(args));				append (env, cons(symbol, cons(value, NIL)));		RETURN tee;			END fnLabel;		(*	static object *fn_cond(object *args, object *env)	{		while (args != NULL && IS_CONS(args)) {			object *cond_and_body = car(args);			object *condition_result = nil;			object *condition = car(cond_and_body);			object *body = car(cdr(cond_and_body));			if (condition != nil)				condition_result = eval(condition, env);			if (condition_result != nil)				return eval(body, env);			args = cdr(args);		}		return NULL;	}	*)		(* Cond *)	PROCEDURE fnCond(args: cell, env: cell): cell;		VAR condAndBody, condResults, condition, body: cell;	BEGIN			WHILE (args # NIL) & (isCons(args)) DO			condAndBody := car(args);			condition := car(condAndBody);			body := car(cdr(condAndBody);						IF condition # nul THEN (* nul = FALSE *)				condResults := eval(condition, env);							IF condResults # nul THEN (* nul = FALSE *)				RETURN eval(body, env);						args := cdr(args);		END;				RETURN NIL;			END fnCond;END LSE;