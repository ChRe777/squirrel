MODULE LSG;	IMPORT		Texts;	CONST		CONS* = 1;		ATOM* = 2;		FUNC* = 3;		LAMBDA* = 4;		NUL = 5;			TYPE		string  = POINTER TO ARRAY OF CHAR; 		cellType = INTEGER;		functionDesc = PROCEDURE (c: cell, c: cell): cell;		function = POINTER TO FunctionDesc;		cellDesc = RECORD			type: cellType;		END;		cell = POINTER TO cellDesc;		atomCellDesc = RECORD (cellDesc)			name: string;		END;		atomCell = POINTER TO atomCellDesc;				nilCellDesc = RECORD (cellDesc)		END;		nilCell = POINTER TO nilCellDesc;				consCellDesc = RECORD (cellDesc)			car: cell;			cdr: cell;		END;		consCell = POINTER TO consCellDesc;		functionCellDesc = RECORD (cellDesc)			fn: function;		END;		functionCell = POINTER TO functionCellDesc;		lambdaCellDesc = RECORD (cellDesc)			args: cell;			sexp: cell;		END;		lambdaCell = POINTER TO lambdaCellDesc;		VAR		tee*: cell; (* Alternate spelling of 't' is tee *)		nul*: cell; (* End of List *)			(* Helper *)				PROCEDURE isAtom(obj: cell): BOOLEAN; BEGIN RETURN (obj.type = ATOM) END;	PROCEDURE isCons(obj: cell): BOOLEAN; BEGIN RETURN (obj.type = CONS) END;	PROCEDURE isFunction(obj: cell): BOOLEAN; BEGIN RETURN (obj.type = FUNC) END;	PROCEDURE isLambda(obj: cell): BOOLEAN; BEGIN RETURN (obj.type = LAMBDA) END;	PROCEDURE cellName(cell: cell): String;	BEGIN		IF isAtom(cell) THEN			return cell(atomCell).name;		ELSE			(* TODO: error object is not an atom *)			RETURN "";		END;	END;			(* MAKER *)	PROCEDURE atom*(name: String): cell;		VAR ac: atomCell;	BEGIN		NEW(ac); ac.type = ATOM; ac.name := name;		RETURN ac;	END atom;		PROCEDURE cons*(car: cell; cdr: cell): cell;		VAR cc: consCell;	BEGIN		NEW(cc); cc.type = CONS; cc.car := car; cc.cdr := cdr;		RETURN cc;	END cons;		PROCEDURE func*(fn: function): cell;		VAR fc: functionCell;	BEGIN		NEW(fc); fc.type = FUNC; fc.fn := fn;		RETURN fc;	END func;		PROCEDURE lambda*(args: cell; sexp: cell): cell;		VAR lc: lambdaCell;	BEGIN		NEW(lc); lc.type = LAMBDA; lc.args := args; lc.sexp := sexp;		RETURN lc;	END lambda;		(* append *)	PROCEDURE append*(list: consCell; c: cell)		VAR cc: consCell;	BEGIN		cc := list;		WHILE cc.cdr # NIL DO 			cc := cc.cdr;		END;		cc.cdr := cons(c, nul);	END append;				(* InitEnv *)	PROCEDURE InitEnv(): cell;		VAR env: consCell;				PROCEDURE functionSymbol(name: String, fn: function): cell;			VAR fc: functionCell;		BEGIN			RETURN cons(					atom(name), 					cons(func(fn), NIL)				);		END functionSymbol;			BEGIN			tee := atom("#T");		nul := cons(NIL, NIL);				env := cons(functionSymbol("QUOTE", fnQuote), NIL);		append(env, cons(functionSymbol("ATOM", fnAtom));		append(env, cons(functionSymbol("EQ", fnEq));				append(env, cons(functionSymbol("CAR", fnCar));		append(env, cons(functionSymbol("CDR", fnCdr));		append(env, cons(functionSymbol("CONS", fnCons));		append(env, cons(functionSymbol("COND", fnCond));				append(env, cons(functionSymbol("LABEL", fnLabel));		append(env, cons(functionSymbol("LAMBDA", fnLambda));			END InitEnv;		(* BUILT IN FUNCTIONS *)	(* Quote *)	PROCEDURE fnQuote(args: cell, env: cell): cell;	BEGIN		RETURN car(args);	END fnQuote;		(* Atom *)		PROCEDURE fnAtom(args: cell, env: cell): cell;		VAR firstArg: consCell;	BEGIN		firstArg := car(args);		IF isCons(firstArg) THEN 			RETURN nul;
		ELSE
			RETURN tee;
	END fnAtom;
	
	(* Eq *)	
	PROCEDURE fnEq(args: cell, env: cell): cell;
		VAR firstArg, secondArg: consCell;
	BEGIN
		firstArg := car(args);
		secondArg := car(cdr(args));
		IF cellName(firstArg) = cellName(secondArg) THEN
			RETURN tee;
		ELSE
			RETURN nul;
	END fnEq;

	(* Car *)
	PROCEDURE fnCar(args: cell, env: cell): cell;
		VAR firstArg: consCell;
	BEGIN
		firstArg := car(args);
		RETURN car(firstArg);
	END fnCar;
	
	(* Cdr *)
	PROCEDURE fnCdr(args: cell, env: cell): cell;
		VAR firstArg: consCell;
	BEGIN
		firstArg := car(args);
		RETURN cdr(firstArg);
	END fnCdr;
	
	
	(*
	static object *fn_cons(object *args, object *env)
	{
		object *list = cons(car(args), NULL);
		args = car(cdr(args));

		// @@@

		while (args != NULL && IS_CONS(args)) {
			ppend(list, car(args));
			args = cdr(args);
		}

		return list;
	}
	*)
	
	(* fnCons *)
	PROCEDURE fnCons(args: cell, env: cell): cell;
		VAR list: consCell;
	BEGIN
		list := cons(car(args), NIL);
		args := car(cdr(args);

		WHILE (args # NIL) & isCons(args) DO
			append(list, car(args));
			args := cdr(args);
		END;
		
		RETURN list;
	END fnCons;
	
	
(*

static object *create_parameter_pairs(object *parameters, object *arguments)
{
    object *pairs;
    object *pair;
    object *param, *arg;

    param = car(parameters);
    arg   = car(arguments);
    pair = cons(param, cons(arg, NULL));

    pairs = cons(pair, NULL);

    parameters = cdr(parameters);
    arguments = cdr(arguments);

    while (parameters != NULL && IS_CONS(parameters)) {
        param = car(parameters);
        arg   = car(arguments);

        pair = cons(param, cons(arg, NULL));
        append(pairs, pair);

        parameters = cdr(parameters);
        arguments  = cdr(arguments);
    }

    return pairs;
}

*)

	(* createParameterPairs *)
	PROCEDURE createParameterPairs(parameters: cell, arguments: cell): cell;
		VAR pairs: cell; pair: cell; param, arg: cell;
	BEGIN
	
		param := car(parameters);
		arg := car(arguments);
		pair := cons(param, cons(arg, NIL);
		
		pairs := cons(pair, NIL);
		
		parameters := cdr(parameters);
		arguments := cdr(arguments);
		
		WHILE (parameters # NIL) & (isCons(paramters)) DO
			param := car(parameters);
			arg := car(arguments);
			pair := cons(param, cons(arg, NIL);
			
			append(pairs, pair); (* could be slow ?? *)
			
			parameters := cdr(parameters);
			arguments := cdr(arguments);
		END;
		
	END createParameterPairs;
	
(*

static object *replace_atom(object *sexp, object *parameter_pairs)
{
    if (IS_CONS(sexp)) {
        object *list;

        list = cons(replace_atom(car(sexp), parameter_pairs), NULL);
        sexp = cdr(sexp);

        while (sexp != NULL && IS_CONS(sexp)) {
            append(list, replace_atom(car(sexp), parameter_pairs));
            sexp = cdr(sexp);
        }

        return list;

    } else {
        object *tmp = parameter_pairs;

        while (tmp != NULL && IS_CONS(tmp)) {
            object *pair = car(tmp);
            object *parameter = car(pair);
            object *argument = car(cdr(pair));

            if (strcmp(object_name(parameter), object_name(sexp)) == 0)
                return argument;

            tmp = cdr(tmp);
        }

        return sexp;
    }
}

*)

	(* replaceAtom *)
	PROCEDURE replaceAtom(sexp: cell; parameterPairs: cell): cell;
		VAR list: cell;
	BEGIN
		IF isCons(sexp) THEN
			list := cons(replaceAtomo(car(sexp), parameterPairs), NIL);
			sexpr := cdr(sexp);

			WHILE (sexp # NIL) & (isCons(sexop)) DO
				append(list, replaceAtom(car(sexp), parameter_pairs));
				sexp := cdr(sexp);
			END;
			RETURN list;
		ELSE
			tmp := parameterPairs;
			
			WHILE (tmp # NIL) & (isCons(tmp)) DO
				pair := car(tmp);
				parameter = car(pair);
				argument = car(cdr(pair));
				
				IF objectName(parameter) = objectName(sexp) THEN
					RETURN argument;
				END;
				
				tmp := cdr(tmp);
			END;
			
			RETURN sexp;
		END;
		
	END replaceAtom;

	
(*

object *fn_lambda(object *args, object *env)
{
	lambda_object *lambda;
	object *arguments, *sexp;
	object *parameter_pairs;

	lambda    = (lambda_object* )car(args);
	arguments = cdr(args);

	parameter_pairs = create_parameter_pairs(lambda->args, arguments);
	sexp = replace_atom(lambda->sexp, parameter_pairs);

	return eval(sexp, env);
}

*)
	
	(* fnLambda *)
	PROCEDURE fnLambda(args: cell, env: cell): cell;
		VAR lambda: lambdaCell; arguments, sexp, parameterPairs: cell;
	BEGIN
		lambda := car(args)(lambdaCell);
		arguments := cdr(args);
		parameterPairs := createParameterPairs(lambda.args, arguments);
		sexp := replaceAtom(lambda.sexp, parameterPairs);
		
		RETURN eval(sexp, env);
	END fnLambda;


(*	
static object *fn_label(object *args, object *env)
{
    object *first_arg = car(args);
    object *symbol = atom(object_name(first_arg));
    object *value  = car(cdr(args));

    append(env, cons(symbol, cons(value, NULL)));
    return tee;
}
*)

	(* fn Label *)
	PROCEDURE fnLabel(args: cell, env: cell): cell;
		VAR firstArg, symbol, value: cell;
	BEGIN
		
		firstArg := car(args);
		symbol := atom(objectName(firstArg));
		value := car(cdr(args));
		
		append (env, cons(symbol, cons(value, NIL)));
		RETURN tee;
		
	END fnLabel;
	
(*

static object *fn_cond(object *args, object *env)
{
    while (args != NULL && IS_CONS(args)) {
        object *cond_and_body = car(args);
        object *condition_result = nil;
        object *condition = car(cond_and_body);
        object *body = car(cdr(cond_and_body));

        if (condition != nil)
            condition_result = eval(condition, env);

        if (condition_result != nil)
            return eval(body, env);

        args = cdr(args);
    }
    return NULL;
}

*)	

	(* Cond *)
	PROCEDURE fnCond(args: cell, env: cell): cell;
		VAR condAndBody, condResults, condition, body: cell;
	BEGIN
	
		WHILE (args # NIL) & (isCons(args) DO
			condAndBody := car(args);
			condition := car(condAndBody);
			body := car(cdr(condAndBody);
			
			IF condition # nul THEN
				condResults := eval(condition, env);
				
			IF condResults # nul THEN
				RETURN eval(body, env);
			
			args := cdr(args);
		END;
		
		RETURN NIL;
		
	END fnCond;
	
	(*
	
	http://paulgraham.com/rootsoflisp.html

	; The Lisp defined in McCarthy's 1960 paper, translated into CL.
	; Assumes only quote, atom, eq, cons, car, cdr, cond.
	; Bug reports to lispcode@paulgraham.com.

	(defun null. (x)
	  (eq x '()))

	(defun and. (x y)
	  (cond (x (cond (y 't) ('t '())))
			('t '())))

	(defun not. (x)
	  (cond (x '())
			('t 't)))

	(defun append. (x y)
	  (cond ((null. x) y)
			('t (cons (car x) (append. (cdr x) y)))))

	(defun list. (x y)
	  (cons x (cons y '())))

	(defun pair. (x y)
	  (cond ((and. (null. x) (null. y)) '())
			((and. (not. (atom x)) (not. (atom y)))
			 (cons (list. (car x) (car y))
				   (pair. (cdr x) (cdr y))))))

	(defun assoc. (x y)
	  (cond ((eq (caar y) x) (cadar y))
			('t (assoc. x (cdr y)))))

	(defun eval. (e a)
	  (cond
		((atom e) (assoc. e a))
		((atom (car e))
		 (cond
		   ((eq (car e) 'quote) (cadr e))
		   ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
		   ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
										(eval. (caddr e) a)))
		   ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
		   ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
		   ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
										(eval. (caddr e) a)))
		   ((eq (car e) 'cond)  (evcon. (cdr e) a))
		   ('t (eval. (cons (assoc. (car e) a)
							(cdr e))
					  a))))
		((eq (caar e) 'label)
		 (eval. (cons (caddar e) (cdr e))
				(cons (list. (cadar e) (car e)) a)))
		((eq (caar e) 'lambda)
		 (eval. (caddar e)
				(append. (pair. (cadar e) (evlis. (cdr e) a))
						 a)))))

	(defun evcon. (c a)
	  (cond ((eval. (caar c) a)
			 (eval. (cadar c) a))
			('t (evcon. (cdr c) a))))

	(defun evlis. (m a)
	  (cond ((null. m) '())
			('t (cons (eval.  (car m) a)
					  (evlis. (cdr m) a)))))
	*)

	(* Eval *)
	PROCEDURE Eval*(sexp: cell, env: cell): cell;
	BEGIN
	END Eval;
		
END LSG.
